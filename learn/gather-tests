#!/usr/bin/python3
# -*- coding: utf-8 -*-

# This file is part of Cockpit.
#
# Copyright (C) 2017 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import gzip
import os
import shutil
import signal
import subprocess
import sys
import tempfile
import urllib.request

sys.dont_write_bytecode = True

def upload(dest, outname):
    sys.stderr.write("upload {}\n".format(dest))
    if "://" in dest:
        cmd = ["curl", "--fail", "--upload-file", outname, dest ]
        curl = subprocess.Popen(cmd)
        ret = curl.wait()
        if ret == 0:
            os.unlink(outname)
        else:
            sys.stderr.write("image-upload: unable to upload image: {0}\n".format(dest))
        return ret
    else:
        os.rename(outname, dest)
        return 0

def run(filename, pipeline, verbose=False):
    if filename == '-' or "://" in filename:
        directory = os.getcwd()
    else:
        directory = os.path.dirname(filename)

    env = os.environ.copy()
    base = os.path.abspath(os.path.dirname(__file__))
    env["PATH"] = "{0}:{1}".format(os.environ.get("PATH", ""), base)
    env["TEST_VERBOSE"] = "1"

    if filename.endswith(".gz"):
        pipeline = list(pipeline)
        pipeline.insert(0, "gunzip -f")
        pipeline.append("gzip")

    ret = 0
    outfd = -1

    try:
        # A tempporary output filename if we're dealing with files
        if filename != '-':
            (outfd, outname) = tempfile.mkstemp(prefix=os.path.basename(filename), dir=directory)

        # Start the pipeline
        input = subprocess.PIPE
        output = subprocess.PIPE
        procs = []
        for i, command in enumerate(pipeline):
            # If the last command in the pipeline output to the file
            if i == len(pipeline) - 1:
                output = outfd
            pipe = subprocess.Popen([ "/bin/sh", "-c", command ], env=env, stdin=input, stdout=output)
            procs.append(pipe)
            input = pipe.stdout

        # Open the input for the pipeline
        seed = None
        if filename == '-':
            seed = sys.stdin
        elif "://" in filename:
            seed = urllib.request.urlopen(filename)
        elif os.path.exists(filename):
            seed = open(filename, 'rb')
        if seed:
            shutil.copyfileobj(seed, procs[0].stdin)

    # Ignore 404 errors
    except urllib.error.HTTPError as ex:
        if ex.code != 404:
            raise

    # Let the pipeline finish
    finally:
        if seed:
            seed.close()
        if procs:
            procs[0].stdin.close()
        for proc in procs:
            ret &= proc.wait()
        if outfd >= 0:
            os.close(outfd)

    sys.stderr.write("done {}\n".format(ret))
    if ret == 0:
        ret = upload(filename, outname)

    return ret

def main():
    parser = argparse.ArgumentParser(description="Gather test data")
    parser.add_argument('--verbose', action='store_true', help='Print verbose retrieval data')
    parser.add_argument('filename', help='The file name to write and read from')
    parser.add_argument('pipeline', nargs='+', help='The command or commands to use as a pipe')
    opts = parser.parse_args()

    return run(opts.filename, opts.pipeline, opts.verbose)

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(128 + signal.SIGINT)
