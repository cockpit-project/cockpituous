#!/usr/bin/python3
# -*- coding: utf-8 -*-

# This file is part of Cockpit.
#
# Copyright (C) 2017 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import gzip
import os
import shutil
import signal
import subprocess
import sys
import tempfile
import urllib.request

sys.dont_write_bytecode = True

def upload(dest, outname):
    sys.stderr.write("upload {}\n".format(dest))
    if "://" in dest:
        cmd = ["curl", "--fail", "--upload-file", outname, dest ]
        curl = subprocess.Popen(cmd)
        ret = curl.wait()
        if ret == 0:
            os.unlink(outname)
        else:
            sys.stderr.write("image-upload: unable to upload image: {0}\n".format(dest))
        return ret
    else:
        os.rename(outname, dest)
        return 0

def run(filename, pipeline, verbose=False):
    if "://" in filename:
        directory = os.getcwd()
    else:
        directory = os.path.dirname(filename)

    # Seed with our input data
    (outfd, outname) = tempfile.mkstemp(prefix=os.path.basename(filename), dir=directory)
    os.close(outfd)

    env = os.environ.copy()
    base = os.path.abspath(os.path.dirname(__file__))
    env["PATH"] = "{0}:{1}".format(os.environ.get("PATH", ""), base)
    env["TEST_VERBOSE"] = "1"

    if filename.endswith(".gz"):
        pipeline = "gunzip -f | " + pipeline + " | gzip"

    with open(outname, 'wb') as fp:
        pipe = subprocess.Popen([ "/bin/sh", "-c", pipeline ], env=env, stdin=subprocess.PIPE, stdout=fp)
        seed = None
        try:
            if "://" in filename:
                seed = urllib.request.urlopen(filename)
            elif os.path.exists(filename):
                seed = open(filename, 'rb')
            if seed:
                shutil.copyfileobj(seed, pipe.stdin)
        except urllib.error.HTTPError as ex:
            if ex.code != 404:
                raise
        finally:
            if seed:
                seed.close()
            if pipe:
                pipe.stdin.close()
                ret = pipe.wait()

    sys.stderr.write("done {}\n".format(ret))
    if ret == 0:
        ret = upload(filename, outname)

    return ret

def main():
    parser = argparse.ArgumentParser(description="Gather test data")
    parser.add_argument('--verbose', action='store_true', help='Print verbose retrieval data')
    parser.add_argument('filename', help='The file name to write and read from')
    parser.add_argument('pipeline', nargs='+', help='The command or commands to use as a pipe')
    opts = parser.parse_args()

    pipeline = " ".join(opts.pipeline)
    return run(opts.filename, pipeline, opts.verbose)

if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(128 + signal.SIGINT)
