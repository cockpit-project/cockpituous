#!/bin/sh -euf
#
# release-source
#
# A script that takes a git repo in the current working directory and builds
# a tarball from a tag plus full tarball patches for each commit up until
# the current HEAD. The patch files include files generated by autotools
# or dist/ directories.
#
# The output patchset is in git patch format with the intent that it can
# contain binary patches. The resulting patch file names are placed in the
# current directory and their names are printed on stdout.
#
# $ git tag -as 122
# $ release-source -o source-output
#
# Will symlink the tarball to the path you specify, so it's easily retrieved.
# while retaining its original name in the linked to file.
#
# If no tag is specified then the most recent numeric tag is used.
#
# Arguments are described here. Most arguments have an equivalent envvar.
#
# -f tgz                            Already created input tarball for when only
#                                   source patches are desired.
# -o dir     RELEASE_SOURCE=dir     Directory to place source at. This directory
#                                   will be cleared if it exists.
# -q         RELEASE_QUIET=1        Make output more quiet
# -t tag     RELEASE_TAG=tag        When no patches are specified, this is a git
#                                   repository tag to get patches until HEAD
#                                   base tarball and defaults to latest tag.
# -v         RELEASE_VERBOSE=1      Make output more verbose
#

set -euf

QUIET=${RELEASE_QUIET:-0}
VERBOSE=${RELEASE_VERBOSE:-0}
OUTPUT=${RELEASE_SOURCE:-}
TAG=${RELEASE_TAG:-}

TARBALL=""

# When building tarballs it's important to have a consistent
# locale and charmap in particular when generating documentation
LANG=en_US.UTF-8
export LANG

usage()
{
    echo "usage: release-source [-qv] [-t TAG] [-o DIRECTORY] [-f TARBALL]" >&2
    exit ${1:-2}
}

trace()
{
    if [ $QUIET -eq 0 ]; then
        echo "> $@" >&2
    fi
}

message()
{
    echo "release-source: $@" >&2
}

# Runs autogen.sh or configure in the source directory
# with a $(builddir) subdirectory of '_build'
#  $1: The source directory
autogen_or_configure()
{
    mkdir -p $1/_build
    if [ -f $1/configure ]; then
        ( cd $1/_build && ../configure )
    else
        ( cd $1 && NOCONFIGURE=1 ./autogen.sh && cd _build && ../configure )
    fi
}

# Use the specified patches to build an input git repo
# Expands commits in input repo into full tarball patches
prepare()
{
    local workdir srcdir commit first archive author date

    if [ -z "$OUTPUT" ]; then
        OUTPUT=.
    elif [ -d "$OUTPUT" ]; then
        find "$OUTPUT" -type f -delete
    elif [ -e "$OUTPUT" ]; then
        message "output directory exists and is not a directory: $OUTPUT"
    else
        mkdir -p "$OUTPUT"
    fi

    workdir=$(mktemp --directory .sources.XXXXXX)
    repodir=$workdir/repo
    stagedir=$workdir/stage

    # Clone the repo into our repodir
    git clone -q . $repodir

    # The stage where we put tarball output
    mkdir $stagedir
    git -C $stagedir init -q
    git -C $stagedir config core.autocrlf false
    git -C $stagedir config core.safecrlf false
    git -C $stagedir config gc.auto 0

    # Mark all sorts of extra files as binary for diffing purposes
    printf "*.min.* binary\n*.map binary\n" > $stagedir/.git/info/attributes

    # Build the tarballs for each commit from $TAG to HEAD inclusive
    first=1
    git log --reverse --pretty='%H' $TAG~1.. | while read commit; do
        git -C $repodir checkout -q --detach $commit

        # The first time a real tarball or provided
        if [ $first -eq 1 ]; then

            # Optimization, if the tarball already exists then just use it on the first pass
            if [ -n "$TARBALL" ]; then
                archive="$TARBALL"
                first=0

            else
                trace "Creating first tarball"

                autogen_or_configure $repodir
                make -C $repodir/_build --silent dist
                printf 'include Makefile\nprint-DIST_ARCHIVES:\n\t@echo $(DIST_ARCHIVES)' \
                    > $repodir/_build/GNUmakefile
                archives="$(make -s -C $repodir/_build print-DIST_ARCHIVES)"

                for name in $archives; do
                    if [ $first -eq 1 ]; then
                        archive="$repodir/_build/$name"
                        first=0
                    fi
                    cp "$repodir/_build/$name" "$OUTPUT"
                done
            fi

            trace "Committing tarball"
            # HACK: Exclude node_modules/ which was in cockpit tarballs
            tar -C $stagedir --exclude="node_modules" --strip-components=1 -xf "$archive"
            git -C $stagedir add -f .
            git -C $stagedir commit -q --message="initial"
            git -C $stagedir tag -a initial --message="initial"

        # Optimize somewhat after that by using a simple gzip tarball
        else
            trace "Creating patched tarball"

            # Try to build without clearing out build. This allows us to trend toward a
            # shorter patch set and build time if all goes well ... then fall back to a
            # hard reset and reconfigure if the fast approach doesn't work.
            if ! make -C $repodir/_build --silent dist-gzip distdir=release-patched; then
                trace "Cleaning out build and trying again"
                rm -rf $repodir/_build
                autogen_or_configure $repodir
                make -C $repodir/_build --silent dist-gzip distdir=release-patched
            fi

            # TODO: So if the above make dist-gzip fails there is the opportunity
            # to automatically combine patches at this level, if one patch breaks
            # building a tarball, but the next fixes it.

            trace "Committing tarball"

            # Now extract the tarball into our stage directory and commit it
            # HACK: Exclude node_modules/ which was in cockpit tarballs
            tar -C $stagedir --exclude="node_modules" --strip-components=1 -xzf - \
                < $repodir/_build/release-patched.tar.gz
            git -C $stagedir add -f .

            # Transfer key information to new stage commit
            author="$(git -C $repodir show $commit --pretty='%an <%ae>' --no-patch)"
            date="$(git -C $repodir show $commit --pretty='%ad' --no-patch)"
            git -C $repodir show $commit --pretty='%B' --no-patch |
                git -C $stagedir commit -q --author="$author" --date="$date" --file=- --no-edit
        fi
    done

    trace "Extracting tarball expanded patches"

    # Extract patches for everything that was staged and put in right place
    mkdir $stagedir/_build
    git -C $stagedir format-patch --output-directory=_build initial..
    find $stagedir/_build -type f -exec mv {} "$OUTPUT" \;

    rm -rf $workdir
}

while getopts "f:p:qt:vx" opt; do
    case "$opt" in
    f)
        TARBALL="$OPTARG"
        ;;
    o)
        OUTPUT="$OPTARG"
        ;;
    q)
        QUIET=1
        VERBOSE=0
        ;;
    t)
        TAG="$OPTARG"
        ;;
    v)
        QUIET=0
        VERBOSE=1
        ;;
    -)
        break
        ;;
    *)
        usage
        ;;
    esac
done

shift $(expr $OPTIND - 1)

if [ $VERBOSE -eq 1 ]; then
    set -x
fi

# The tag for the release
if [ -z "$TAG" ]; then
    TAG=$(git describe --match='[0-9]*' --abbrev=0 || true)
    if [ -z "$TAG" ]; then
        message "could not find a tag to build"
        exit 2
    fi
fi

prepare
