#!/bin/sh -euf
#
# release-source
#
# A script that takes a git repo in the current working directory and builds
# a tarball from a tag plus full tarball patches for each commit up until
# the current HEAD. The patch files include files generated by autotools
# or dist/ directories.
#
# The output patchset is in git patch format with the intent that it can
# contain binary patches. The resulting patch file names are placed in the
# current directory and their names are printed on stdout.
#
# $ git tag -as 122
# $ release-source -o source-output
#
# Will symlink the tarball to the path you specify, so it's easily retrieved.
# while retaining its original name in the linked to file.
#
# If no tag is specified then the most recent numeric tag is used.
#
# Arguments are described here. Most arguments have an equivalent envvar.
#
# -f dir     RELEASE_SOURCE=dir     Directory to place source at. If prepopulated
#                                   with source then build will be skipped.
# -q         RELEASE_QUIET=1        Make output more quiet
# -t tag     RELEASE_TAG=tag        When no patches are specified, this is a git
#                                   repository tag to get patches until HEAD
#                                   base tarball and defaults to latest tag.
# -v         RELEASE_VERBOSE=1      Make output more verbose
#

set -euf

QUIET=${RELEASE_QUIET:-0}
VERBOSE=${RELEASE_VERBOSE:-0}
SOURCE=${RELEASE_SOURCE:-}
TAG=${RELEASE_TAG:-}

MAKE="make V=1"

# When building tarballs it's important to have a consistent
# locale and charmap in particular when generating documentation
LANG=en_US.UTF-8
export LANG

usage()
{
    echo "usage: release-source [-qv] [-t TAG] -f SOURCE" >&2
    exit ${1:-2}
}

trace()
{
    if [ $QUIET -eq 0 ]; then
        echo "> $@" >&2
    fi
}

message()
{
    echo "release-source: $@" >&2
}

# Runs autogen.sh or configure in the source directory
# with a $(builddir) subdirectory of '_build'
#  $1: The source directory
autogen_or_configure()
{
    mkdir -p $1/_build
    if [ -f $1/configure ]; then
        ( cd $1/_build && ../configure )
    else
        ( cd $1 && NOCONFIGURE=1 ./autogen.sh && cd _build && ../configure )
    fi
}

# Prints out an existing tarball archive for the given version
#  $1: The tarball version
#  $2: The directory containing tarballs
find_and_extract_tarballs()
{
    local archive name

    archive=
    find "$2" -maxdepth 1 -name "*-$1.tar.*" | LC_ALL=C sort | while read name; do

        tar -xf "$name" -C "$3" --strip-components=1
	git -C "$3" reset --quiet --hard HEAD

        # The first tarball is the main one
        if [ -z "$archive" ]; then
            archive="$name"
            echo "$name"
	fi
    done
}

# Copies all tarballs from build into source directory, clears
# all previously existing tarballs, and prints name of first tarball
#  $1: The make build directory
#  $2: The directory to put tarballs
output_tarballs()
{
    local archive name

    archive=
    printf 'include Makefile\nprint-DIST_ARCHIVES:\n\t@echo $(DIST_ARCHIVES)' \
        | make -C "$1" -s -f - print-DIST_ARCHIVES | tr ' ' '\n' | while read name; do

        # Once we see the first archive, clear old stuff
        if [ -z "$archive" ]; then
            find "$2" -maxdepth 1 -name "*-*.tar.*" -delete
            archive="$2/$name"
            echo "$archive"
        fi

        cp -t "$2" "$1/$name"
    done
}


# Use the specified patches to build an input git repo
# Expands commits in input repo into full tarball patches
prepare()
{
    local workdir stagedir repodir commit archive archives author date name exist

    workdir=$(mktemp --directory source.XXXXXX)
    repodir=$workdir/repo
    stagedir=$workdir/stage
    archive=""

    mkdir -p "$SOURCE"

    # Clone the repo into our repodir
    git clone -q . $repodir

    # Build the tarballs for each commit from $TAG to HEAD inclusive
    git log --reverse --pretty='%H' $TAG~1.. | while read commit; do
        git -C $repodir checkout -q --detach $commit

        # The first time a real tarball or provided
        if [ -z "$archive" ]; then

            # Find archives in the source directory
            archive="$(find_and_extract_tarballs $TAG $SOURCE $repodir)"

            # If it is missing rebuild the tarball and copy into place
            if [ -z "$archive" ]; then
                trace "Creating first tarball"

                autogen_or_configure $repodir
                $MAKE -C $repodir/_build dist

                archive="$(output_tarballs $repodir/_build $SOURCE)"
            fi

        else

            # The first patch, make a git repo and extract our tarball
            if [ ! -d $stagedir ]; then

                trace "Committing first tarball"
                mkdir $stagedir
                git -C $stagedir init -q
                git -C $stagedir config core.autocrlf false
                git -C $stagedir config core.safecrlf false
                git -C $stagedir config gc.auto 0

                # Mark all sorts of extra files as binary for diffing purposes
                printf "*.min.* binary\n*.map binary\n/dist/** binary\n" > $stagedir/.git/info/attributes

                # HACK: Exclude node_modules/ which was in cockpit tarballs
                tar -C $stagedir --exclude="node_modules" \
                    --strip-components=1 -xf "$archive"
                git -C $stagedir add -f .
                git -C $stagedir commit -q --message="initial"
                git -C $stagedir tag -a initial --message="initial"
            fi

            trace "Creating patched tarball"

            # Some software looks at its version number from the git tag
            # so we move the git version tag here to this specific patch commit
            git -C $repodir tag -d $TAG || true
            git -C $repodir tag -a -m "Retag" $TAG

            # Try to build without clearing out build. This allows us to trend toward a
            # shorter patch set and build time if all goes well ... then fall back to a
            # hard reset and reconfigure if the fast approach doesn't work.
            if ! $MAKE -C $repodir/_build dist-gzip distdir=release-patched; then
                trace "Cleaning out build and trying again"

                rm -rf $repodir/_build
                autogen_or_configure $repodir
                $MAKE -C $repodir/_build dist-gzip distdir=release-patched
            fi

            # TODO: So if the above make dist-gzip fails there is the opportunity
            # to automatically combine patches at this level, if one patch breaks
            # building a tarball, but the next fixes it.

            trace "Committing tarball"

            # Now extract the tarball into our stage directory and commit it
            # HACK: Exclude node_modules/ which was in cockpit tarballs
            tar -C $stagedir --exclude="node_modules" \
                --strip-components=1 -xzf - < $repodir/_build/release-patched.tar.gz
            git -C $stagedir add -f .

            # If nothing added above, then just skip
            if git -C $stagedir diff-index --exit-code --quiet HEAD --; then
                continue
            fi

            # Transfer key information to new stage commit
            author="$(git -C $repodir show $commit --pretty='%an <%ae>' --no-patch)"
            date="$(git -C $repodir show $commit --pretty='%ad' --no-patch)"
            git -C $repodir show $commit --pretty='%B' --no-patch |
                git -C $stagedir commit -q --author="$author" --date="$date" --file=- --no-edit
        fi
    done

    trace "Extracting tarball expanded patches"

    # Extract patches for everything that was staged and put in right place
    find "$SOURCE" -maxdepth 1 -name '*.patch' -delete
    if [ -d $stagedir ]; then
        mkdir $stagedir/_build
        git -C $stagedir format-patch --output-directory=_build initial..
        find $stagedir/_build -type f -exec mv {} "$SOURCE" \;
    fi

    rm -rf $workdir
}

while getopts "f:p:qt:vx" opt; do
    case "$opt" in
    f)
        SOURCE="$OPTARG"
        ;;
    q)
        QUIET=1
        VERBOSE=0
        ;;
    t)
        TAG="$OPTARG"
        ;;
    v)
        QUIET=0
        VERBOSE=1
        ;;
    -)
        break
        ;;
    *)
        usage
        ;;
    esac
done

shift $(expr $OPTIND - 1)

if [ $VERBOSE -eq 1 ]; then
    set -x
elif [ $QUIET -eq 1 ]; then
    MAKE="make --silent"
fi

if [ -z "$SOURCE" ]; then
    message "no source directory specified"
    exit 2
fi

# The tag for the release
if [ -z "$TAG" ]; then
    TAG=$(git describe --match='[0-9]*' --abbrev=0 || true)
    if [ -z "$TAG" ]; then
        message "could not find a tag to build"
        exit 2
    fi
fi

prepare
